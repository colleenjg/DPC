#!/usr/bin/env python

import argparse
import copy
from pathlib import Path
import logging
import sys
import time
import warnings

from joblib import delayed, Parallel
import json
from matplotlib import pyplot as plt
import numpy as np
import torch
from tqdm import tqdm

sys.path.extend(["..", str(Path("..", "utils"))])
from utils import loss_utils, misc_utils

BASE_SEQ = ["A", "B", "C", "D"]
NUM_MEAN_ORIS = 8
U_ADJ = 90

DEG = u"\u00b0"
GABOR_CONF_MAT_DIREC = "gabor_confusion_matrices"


logger = logging.getLogger(__name__)


#############################################
class GaborConfusionMeter(loss_utils.ConfusionMeter):
    """
    Class for computing and plotting Gabor sequence classification performance 
    in a confusion matrix.

    See loss_utils.ConfusionMeter for inherited attributes and methods.
    
    Attributes
    ----------
    - self.mean_oris : list
        Unique mean orientations, retrieved from the class names.
    - self.image_types : list
        Unique image types, retrieved from the class names.
    - self.nest_idx : 1D array
        Indices for reordering classes to nest frames (i.e., image types).
    - self.unnest_idx : 1D array
        Indices for retrieving class order after nesting frames 
        (i.e., image types).
    - self.U_prob : float
        Probability of U frames.
    - self.unexp : bool
        Whether unexpected sequences are included.

    Methods
    -------
    - self.delete_properties()
        Deletes properties that have been initialized.
    - self.get_labels()
        Returns ordered class names for use as labels.
    - self.get_main_edges()
        Returns axis values that mark the edges between main labels.
    - self.get_ori_str(ori)
        Returns orientation values as strings.
    - self.get_main_label_dict()
        Returns dictionary mapping main labels to axis values.
    - self.get_nested_label_dict()
        Returns dictionary mapping nested labels to axis values.
    - self.get_storage_dict()
        Returns the object data in a storage dictionary that can be directly 
        saved as a json file.
    - self.load_from_storage_dict()
        Reinitializes the current object based on a storage dictionary 
        previously generated by self.get_storage_dict().
    - self.plot_mat()
        Plots and optionally saves the confusion matrix.
    - self.reinitialize_values_gabors(class_names)
        Reinitializes current object with new class names.
    """

    def __init__(self, class_names, U_prob=0.08, unexp=False):
        """
        GaborConfusionMeter(class_names)

        Constructs a GaborConfusionMeter object.

        Required args
        -------------
        - class_names : array-like
            Ordered class names, where each class name is 
            (image_type, orientation).

        Optional args
        -------------
        - U_prob : float (default=0.08)
            Probability of U frames.
        - unexp : bool (default=False)
            Whether unexpected sequences are included.
        """

        self._set_properties = []
        self.reinitialize_values_gabors(class_names, U_prob, unexp)
        super().__init__(class_names)


    def delete_properties(self):
        """
        self.delete_properties()

        Deletes properties that have been initialized.
        """
        
        for attr_name in self._set_properties:
            delattr(self, attr_name)
        self._set_properties = []


    def reinitialize_values_gabors(self, class_names, U_prob=0.08, unexp=False):
        """
        self.reinitialize_values_gabors(class_names)

        Reinitializes the attributes and properties of the current 
        GaborConfusionMeter object based on new class names.

        Required args
        -------------
        - class_names : array-like
            Ordered class names, where each class name is 
            (image_type, orientation).

        Optional args
        -------------
        - U_prob : float (default=0.08)
            Probability of U frames.
        - unexp : bool (default=False)
            Whether unexpected sequences are included.
        """
        
        self.delete_properties()
        class_names = [tuple(class_name) for class_name in class_names]
        super().reinitialize_values(class_names=class_names)

        image_types, mean_oris = list(zip(*class_names))

        self.U_prob = float(U_prob)
        self.set_unexp(unexp)

        self.image_types = sorted(set(image_types))
        if "N/A" in mean_oris:
            mean_oris = sorted(set([ori for ori in mean_oris if ori != "N/A"]))
            mean_oris.append("N/A")
        else:
            mean_oris = sorted(set(mean_oris))
        self.mean_oris = mean_oris


    @property
    def nest_idx(self):
        """
        self.nest_idx

        Returns indices for reordering classes to nest frames 
        (i.e., image types).
        """

        if not hasattr(self, "_nest_idx"):
            nest_idx = []
            for mean_ori in self.mean_oris:
                for image_type in self.image_types:
                    label = (image_type, mean_ori)
                    if label in self.class_names:
                        idx = self.class_names.index((image_type, mean_ori))
                        nest_idx.append(idx)
            nest_idx = np.asarray(nest_idx)
            if len(nest_idx) != len(self.class_names):
                raise RuntimeError(
                    "'nest_idx' and 'self.class_names' lengths do not match."
                    )
            if len(np.unique(nest_idx)) != len(self.class_names):
                raise RuntimeError("Duplicate class names or indices found.")

            self._nest_idx = nest_idx
            self._set_properties.append("_nest_idx")
        
        return self._nest_idx


    @property
    def unnest_idx(self):
        """
        self.unnest_idx

        Returns indices for retrieving class order after nesting frames 
        (i.e., image types).
        """

        if not hasattr(self, "_unnest_idx"):
            self._unnest_idx = np.argsort(self.nest_idx)
            self._set_properties.append("_unnest_idx")
        
        return self._unnest_idx

    def set_unexp(self, unexp=False):
        """
        self.set_unexp()

        Optional args
        -------------
        - unexp : bool (default=False)
            Whether unexpected sequences are included.
        """

        self.unexp = bool(unexp)


    def get_labels(self, nest_frames=False):
        """
        self.get_labels()

        Returns ordered class names for use as labels.

        Optional args
        -------------
        - nest_frames : bool (default=False)
            Whether to rearrange class names in order to nest frames 
            (image types), instead of preserving the original class label order.

        Returns
        -------
        - labels : list
            Class names, optionally reordered, for use as labels.
        """

        if nest_frames:
            labels = [self.class_names[i] for i in self.nest_idx]
        else:
            labels = [cl_name for cl_name in self.class_names]

        return labels


    def get_main_edges(self, nest_frames=False):
        """
        self.get_main_edges()

        Returns axis values that mark the edges between main (not nested) 
        labels.

        Optional args
        -------------
        - nest_frames : bool (default=False)
            Whether the frames (image types) are nested. If so, the edges 
            between different orientations are returned. Otherwise, 
            orientations are considered nested, and the edges between image 
            types are returned.

        Returns
        -------
        - main_edges : list
            Axis values marking the edges between main labels.
        """

        labels = self.get_labels(nest_frames)
        idx = 1 if nest_frames else 0

        main_edges = [0]
        curr_val = labels[0][idx]
        for l, label in enumerate(labels):
            if label[idx] != curr_val:
                main_edges.append(l)
                curr_val = label[idx]
        main_edges.append(len(labels))

        return main_edges


    def get_ori_str(self, ori):
        """
        self.get_ori_str(ori)

        Returns a string for the orientation (in degrees) passed.

        Required args
        -------------
        - ori : float or str
            Orientation (in degrees) to return as a string.
        
        Returns
        -------
        - ori : str
            Orientation, as a string
        """

        if ori != "N/A":
            ori = float(ori)
            if int(ori) == ori:
                ori = int(ori)
            ori = u"{}{}".format(ori, DEG)
        return ori


    def get_main_label_dict(self, nest_frames=False):
        """
        self.get_main_label_dict()

        Returns dictionary mapping main labels to their axis values.

        Optional args
        -------------
        - nest_frames : bool (default=False)
            Whether the frames (image types) are nested. If so, the 
            orientations are the main labels. Otherwise, the image types are 
            considered the main labels.

        Returns
        -------
        - main_label_dict : dict
            Dictionary mapping main labels to their axis values.
        """
        
        labels = self.get_labels(nest_frames)
        main_edges = self.get_main_edges(nest_frames)
        main_idx = 1 if nest_frames else 0

        main_label_dict = dict()
        for e, edge in enumerate(main_edges[:-1]):
            mid_e = np.mean([edge, main_edges[e + 1]]) - 0.5
            label = labels[edge][main_idx]
            if nest_frames:
                label = self.get_ori_str(label)
            main_label_dict[mid_e] = label
        
        return main_label_dict


    def get_nested_label_dict(self, nest_frames=False):
        """
        self.get_nested_label_dict()

        Returns dictionary mapping nested labels to their axis values.

        Optional args
        -------------
        - nest_frames : bool (default=False)
            Whether the frames (image types) are nested. If so, the 
            image types are the nested labels. Otherwise, the image 
            types are considered the nested labels.

        Returns
        -------
        - nested_label_dict : dict
            Dictionary mapping nested labels to their axis values.

        """
        
        labels = self.get_labels(nest_frames)
        nested_idx = 0 if nest_frames else 1

        nested_label_dict = dict()
        for i, label in enumerate(labels):
            label = label[nested_idx]
            if not nest_frames:
                label = self.get_ori_str(label)
            nested_label_dict[i] = label

        return nested_label_dict


    def plot_mat(self, save_path=None, nest_frames=False, title=None, 
                 norm="targ"):
        """
        self.plot_mat()

        Plots and optionally saves the confusion matrix.

        Optional args
        -------------
        - save_path : str or path (default=None)
            Path at which to save confusion matrix, if provided.
        - nest_frames : bool (default=False)
            Whether the frames (image types) are nested. If so, the 
            image types are the nested labels. Otherwise, the image 
            types are considered the nested labels.
        - title : str (default=None)
            Plot title.
        - norm : str (default="targ")
            If not False, dimension by which to normalize the confusion matrix, 
            i.e., either 'targ' for target class frequencies, 'pred' for 
            predicted class frequencies or 'all' for all frequencies.

        Returns
        -------
        if save_path is None:
        - fig : plt Figure
            Figure in which the confusion matrix is plotted.
        """

        # accomodate longer main labels on right
        cbar_kwargs = {"pad" : 0.1}

        try:
            self._mat = copy.deepcopy(self.mat)
            if nest_frames: # nest self.mat, if needed
                self.mat = self.mat[self.nest_idx][:, self.nest_idx]
            fig = super().plot_mat(adj_aspect=norm, norm=norm, **cbar_kwargs)

        finally:
            self.mat = self._mat
            delattr(self, "_mat")                

        ax = fig.axes[0]

        if norm:
            norm_str = f"norm." if norm == "all" else f"norm. by {norm} freq."
            fig.axes[-1].set_ylabel(f"Counts ({norm_str})")

        if title is not None:
            ax.set_title(title, y=1.1)

        # add nested labels
        nested_dict = self.get_nested_label_dict(nest_frames)
        super().add_labels(ax, label_dict=nested_dict)

        # add main labels
        main_dict = self.get_main_label_dict(nest_frames)
        super().add_labels(ax, label_dict=main_dict, secondary=True)

        main_edges = self.get_main_edges(nest_frames)
        if len(main_edges) > 2:
            for edge in main_edges[1:-1]:
                ax.axhline(edge + 0.5, lw=1, color="k")
                ax.axvline(edge + 0.5, lw=1, color="k")

        if save_path is None:
            return fig
        else:
            Path(save_path).parent.mkdir(exist_ok=True, parents=True)
            fig.savefig(save_path, format="svg", bbox_inches="tight", dpi=600)
            plt.close(fig)


    def get_storage_dict(self):
        """
        self.get_storage_dict()

        Returns a storage dictionary containing the properties needed to reload 
        the GaborConfusionMeter object.

        Returns
        -------
        - storage_dict : dict
            Storage dictionary containing the main properties needed to reload 
            the GaborConfusionMeter object.
        """

        storage_dict = super().get_storage_dict()

        all_keys = ["image_types", "mean_oris", "U_prob", "unexp"]
        for key in all_keys:
            data = getattr(self, key)
            if isinstance(data, np.ndarray):
                data = data.tolist()
            storage_dict[key] = data

        return storage_dict

    
    def load_from_storage_dict(self, storage_dict):
        """
        self.load_from_storage_dict(storage_dict)

        Reinitializes the current GaborConfusionMeter object from a storage 
        dictionary generated with self.get_storage_dict().

        Required args
        -------------
        - storage_dict : dict
            Storage dictionary containing the main properties needed to reload 
            the GaborConfusionMeter object.
        """

        self.reinitialize_values_gabors(
            storage_dict["class_names"],
            U_prob=storage_dict["U_prob"],
            unexp=storage_dict["unexp"]
            )

        super().load_from_storage_dict(storage_dict)
        self.class_names = [
            tuple(class_name) for class_name in self.class_names
            ]

        stored_class_names = storage_dict["class_names"]
        if len(self.class_names) != len(stored_class_names):
            raise RuntimeError(
                "'self.class_names' does not have the same number of "
                "labels as the stored 'class_names'."
                )

        for new, stored in zip(self.class_names, stored_class_names):                
            if list(new) != list(stored):
                raise RuntimeError(
                    "'self.class_names' does not exactly match stored "
                    "'class_names'."
                    )


#############################################
def get_mean_oris(num_mean_oris=NUM_MEAN_ORIS):
    """
    get_mean_oris()

    Generates equally spaced mean orientations from 0 to 360 degrees.
    
    Optional args
    -------------
    - num_mean_oris : int (default=NUM_MEAN_ORIS)
        Number of equally spaced orientations.

    Returns
    -------
    - mean_oris : 1D array
        Mean orientations (in degrees).
    """

    mean_oris = np.arange(0, 360, 360 / num_mean_oris)

    return mean_oris


#############################################
def get_mean_U_oris(mean_oris):
    """
    get_mean_U_oris(mean_oris)

    Generates mean U frame orientations, based on orientations for expected 
    frames.
    
    Optional args
    -------------
    - mean_oris : 1D array
        Mean orientations for expected frames (in degrees).

    Returns
    -------
    - mean_oris_U : 1D array
        Mean orientations for U frames (in degrees).
    """

    mean_oris_U = (np.asarray(mean_oris) + U_ADJ) % 360

    return mean_oris_U



#############################################
def get_gabor_classes(num_mean_oris=NUM_MEAN_ORIS, gray=True, U_prob=0.08, 
                      diff_U_possizes=False):
    """
    get_gabor_classes()

    Returns Gabor image type/orientation classes, based on Gabor parameters.
    
    Optional args
    -------------
    - num_mean_oris : int (default=NUM_MEAN_ORIS)
        Number of equally spaced orientations.
    - gray : bool (default=True)
        Whether gray frames are included.
    - U_prob : float (default=0.08)
        Probability of U frames.
    - diff_U_possizes : bool (default=False)
        Whether U frames have different positions/sizes from D frames.

    Returns
    -------
    - classes : list
        List of classes, where each is (image_type, orientation (in degrees))
    """

    mean_oris = np.arange(0, 360, 360 / num_mean_oris)
    frames = copy.deepcopy(BASE_SEQ)

    if U_prob > 0:
        mean_oris_U = (mean_oris + U_ADJ) % 360
        if diff_U_possizes:
            frames.append("U")
        else:
            frames[frames.index("D")] = "D/U"
            DU_mean_oris = np.sort(
                np.unique(np.concatenate([mean_oris, mean_oris_U]))
            )

    classes = []
    for frame in frames:
        if frame == "D/U":
            use_mean_oris = DU_mean_oris
        elif frame == "U":
            use_mean_oris = mean_oris_U
        else:
            use_mean_oris = mean_oris

        for mean_ori in np.sort(use_mean_oris):
            classes.append((frame, mean_ori))
    
    if gray:
        classes.append(("G", "N/A"))

    return classes


#############################################
def get_num_classes(num_mean_oris=NUM_MEAN_ORIS, gray=True, U_prob=0.08, 
                    diff_U_possizes=False):
    """
    get_num_classes()

    Returns number of Gabor image type/orientation classes, based on Gabor 
    parameters.
    
    Optional args
    -------------
    - num_mean_oris : int (default=NUM_MEAN_ORIS)
        Number of equally spaced orientations.
    - gray : bool (default=True)
        Whether gray frames are included.
    - U_prob : float (default=0.08)
        Probability of U frames.
    - diff_U_possizes : bool (default=False)
        Whether U frames have different positions/sizes from D frames.

    Returns
    -------
    - num_classes : int
        Number of classes
    """

    classes = get_gabor_classes(
        num_mean_oris, gray=gray, U_prob=U_prob, 
        diff_U_possizes=diff_U_possizes
        )

    num_classes = len(classes)

    return num_classes


#############################################
def get_image_class_and_label_dict(num_mean_oris=NUM_MEAN_ORIS, gray=True, 
                                   U_prob=0.08, diff_U_possizes=False, 
                                   class_to_label=True):
    """
    get_image_class_and_label_dict()

    Returns a dictionary for associating class names and labels.
    
    Optional args
    -------------
    - num_mean_oris : int (default=NUM_MEAN_ORIS)
        Number of equally spaced orientations.
    - gray : bool (default=True)
        Whether gray frames are included.
    - U_prob : float (default=0.08)
        Probability of U frames.
    - diff_U_possizes : bool (default=False)
        Whether U frames have different positions/sizes from D frames.
    - class_to_label : bool (default=True)
        If True, the dictionary returned has class names as keys, and values as 
        class labels. If False, it is the reverse.

    Returns
    -------
    - image_class_and_label : dict
        Dictionary associating class names to class labels.
    """

    image_classes = get_gabor_classes(
        num_mean_oris, gray=gray, U_prob=U_prob, 
        diff_U_possizes=diff_U_possizes
        )
    
    if class_to_label:
        image_class_and_label_dict = {
            im_cl: label for label, im_cl in enumerate(image_classes)
            }
    else:
        image_class_and_label_dict = {
            label: im_cl for label, im_cl in enumerate(image_classes)
            }

    return image_class_and_label_dict


#############################################
def image_class_to_label(image_class_and_label_dict, seq_image_types, 
                         seq_image_mean_oris, class_to_label=True):
    """
    image_class_to_label(image_class_and_label_dict, seq_image_types, 
                         seq_image_mean_oris)

    Converts class names to labels.
    
    Required args
    -------------
    - image_class_and_label_dict : dict
        Dictionary associating class names to class labels.
    - seq_image_types : array-like
        Image types (e.g., "A", "B", etc.)
    - seq_image_mean_oris : array-like
        Gabor orientations (same shape as seq_image_types, and numerical only)

    Optional args
    -------------
    - class_to_label : bool (default=True)
        If True, the dictionary provided has class names as keys, and class 
        labels as labels. If False, it is the reverse.

    Returns
    -------
    - seq_image_labels : torch Tensor
        Class labels for the input image types and orientations (in degrees)
        (same shape as seq_image_types).
    """

    seq_image_types = np.asarray(seq_image_types)
    seq_image_mean_oris = np.asarray(seq_image_mean_oris)

    if seq_image_types.shape != seq_image_mean_oris.shape:
        raise ValueError(
            "'seq_image_types' and 'seq_image_mean_oris' must have the same "
            "shape."
            )

    orig_shape = seq_image_types.shape
    seq_image_types = seq_image_types.reshape(-1)
    seq_image_mean_oris = seq_image_mean_oris.reshape(-1)

    if class_to_label:
        class_to_label_dict = image_class_and_label_dict
    else:
        class_to_label_dict = {
            im_cl: label for label, im_cl in image_class_and_label_dict.keys()
            }
    
    # if classes don't differentiate between D and U
    dict_images, _ = list(zip(*class_to_label_dict.keys()))
    if "D/U" in dict_images:
        seq_image_types = copy.deepcopy(seq_image_types).astype("<U3") # for "/" character
        seq_image_types[np.where(seq_image_types == "D")] = "D/U"
        seq_image_types[np.where(seq_image_types == "U")] = "D/U"

    seq_image_classes = [
        (i, o) if np.isfinite(o) else (i, "N/A") 
        for i, o in zip(seq_image_types, seq_image_mean_oris) 
        ]

    if not set(seq_image_classes).issubset(set(class_to_label_dict.keys())):
        raise ValueError(
            "'seq_image_types' and 'seq_image_mean_oris' contain combinations "
            "that do not occur in 'image_class_and_label_dict'."
            )

    seq_image_labels = torch.as_tensor(
        [class_to_label_dict[im_cl] for im_cl in seq_image_classes]
    ).reshape(orig_shape)
        
    return seq_image_labels


#############################################
def get_unexp(image_types):
    """
    get_unexp(image_types)

    Returns boolean area indicating which image types are unexpected 
    (i.e., U frames).

    Required args
    -------------
    - image_types : array-like
        Image types (e.g., "A", "B", etc.)

    Optional args
    -------------
    - class_to_label : bool (default=True)
        If True, the dictionary provided has class names as keys, and class 
        labels as labels. If False, it is the reverse.

    Returns
    -------
    - unexp : nd Tensor
        Boolean array indicating which image types are unexpected ("U")
        (same shape as image_types).
    """

    image_types = np.asarray(image_types)

    if "D/U" in image_types:
        raise ValueError(
            "'image_types' must not contain 'D/U' values. "
            "Only 'D' or 'U', individually."
            )

    unexp = torch.as_tensor(image_types == "U")

    return unexp


#############################################
def specify_image_types(image_types, unexp):
    """
    specify_image_types(image_types, unexp)

    Returns specific image types, replacing "D/U" with either "D" or "U", 
    based on the information contained in unexp.

    Required args
    -------------
    - image_types : array-like
        Image types (e.g., "A", "B", etc.)
    - unexp : array-like
        Boolean array indicating which image types are unexpected ("U")
        (same shape as image_types).

    Returns
    -------
    - image_types : nd-array
        Image types (e.g., "A", "B", etc.) (same shape as image_types input)
    """

    image_types = np.asarray(image_types)
    unexp = np.asarray(unexp).astype(bool)

    if image_types.shape != unexp.shape:
        raise ValueError("'image_types' and 'unexp' must have the same shape.")

    if "D/U" in image_types:
        image_types = copy.deepcopy(image_types)
        image_types[image_types == "D/U"] = "D"
        if (image_types[unexp] != "D").any():
            raise ValueError("Some unexpected image types are not D/Us.")
        image_types[unexp] = "U"
    
    if ((image_types == "U") != unexp).any():
        raise RuntimeError(
            "U images cannot be correctly inferred from 'image_types' and "
            "'unexp'."
            )

    return image_types


#############################################
def image_label_to_class(image_label_and_class_dict, seq_labels, 
                         label_to_class=True, seq_unexp=None):
    """
    image_label_to_class(image_label_and_class_dict, seq_labels)

    Converts class labels to names.
    
    Required args
    -------------
    - image_label_and_class_dict : dict
        Dictionary associating class labels to class names.
    - seq_labels : array-like
        Image class labels

    Optional args
    -------------
    - label_to_class : bool (default=True)
        If True, the dictionary provided has class labels as keys, and class 
        names as names. If False, it is the reverse.
    - seq_unexp : array-like (default=None)
        Boolean array indicating which image types are unexpected ("U")
        (same shape as seq_labels). If not provided, any "D/U" values are 
        retained.

    Returns
    -------
    - seq_classes : list
        Class names for the input class labels (same structure as seq_labels), 
        where each class is (image_type, orientation (in degrees)).
    """

    seq_labels = np.asarray(seq_labels)

    orig_shape = seq_labels.shape
    seq_labels = seq_labels.reshape(-1)

    if label_to_class:
        label_to_class_dict = image_label_and_class_dict
    else:
        label_to_class_dict = {
            label: im_cl for im_cl, label in image_label_and_class_dict.keys()
            }

    # check that all labels exist in the dictionary
    if not set(seq_labels).issubset(set(label_to_class_dict.keys())):
        raise ValueError(
            "'seq_labels' contains labels not present in "
            "'image_label_and_class_dict'."
            )

    seq_classes = [
        label_to_class_dict[i] for i in seq_labels
    ]

    # convert to D or U instead of D/U, if applicable
    if seq_unexp is not None:
        seq_unexp = np.asarray(seq_unexp)
        if seq_unexp.shape != orig_shape:
            raise ValueError(
                "If provided, 'seq_unexp' must have the same shape as "
                "'seq_labels'."
                )

        image_types, mean_oris = list(zip(*seq_classes))
        image_types = specify_image_types(image_types, seq_unexp.reshape(-1))
        seq_classes = list(zip(image_types, mean_oris))

    seq_classes = misc_utils.renest(seq_classes, orig_shape)

    return seq_classes

#############################################
def get_best_acc(best_accs, save_best=True, unexp=None):
    """
    get_best_acc(best_accs)

    Returns the best accuracy values to which to compare new accuracy values, 
    for training/evaluating on [exp, unexp] Gabor dataset sequences.

    Optional args
    -------------
    - best_accs : float or list (default=None)
        Initial best accuracy value(s) based on which to calculate output, as 
        either a list [exp, unexp], or a single value, specified by unexp. 
        If None, the output is set to -np.inf, unless save_best is False.
    - save_best : bool (default=True)
        If False, the output best accuracy is set to None. 
    - unexp : bool (default=None)
        Whether best_accs, if a float, specifies the best accuracy for exp or 
        unexp training/evaluating.

    Returns
    -------
    - best_accs : list
        Best accuracy values to use in comparison [exp, unexp].
    """

    if not isinstance(best_accs, list):
        best_accs = [None, None] # exp, unexp
        if unexp is not None:
            best_accs[int(unexp)] = best_accs

    best_accs = [
        loss_utils.get_best_acc(acc, save_best) for acc in best_accs
        ]

    return best_accs


#############################################
def update_dataset_possizes(main_loader, val_loader=None, seed=None, incr=0):
    """
    update_dataset_possizes(main_loader)

    Updates Gabor dataset position and sizes, if the dataset has set 
    positions and sizes (main_loader.dataset.same_possizes is True).
    
    Required args
    -------------
    - main_loader : torch data.DataLoader
        Torch dataloader.

    Optional args
    -------------
    - val_loader : torch data.DataLoader (default=None)
        Torch dataloader.
    - seed : int (default=None)
        Seed.
    - incr : int (default=0)
        Value by which to increment the seed.

    Returns
    -------
    - seed : int
        Base seed value used, randomly selected if the input seed value is None.
    """

    if not main_loader.dataset.same_possizes:
        return

    if seed is None:
        seed = np.random.choice(int(2**32))
    
    main_loader.dataset.set_possizes(seed=seed + incr, reset=True)
    
    if val_loader is not None:
        if not val_loader.dataset.same_possizes:
            return
        val_loader.dataset.set_possizes(seed=seed + incr, reset=True)    

    return seed


#############################################
def update_unexp(main_loader, val_loader=None, epoch_n=0, unexp_epoch=10, 
                 test=False, num_unexp=4):
    """
    update_unexp(main_loader)

    Checks whether Gabor dataset unexpected attribute should be updates. If so, 
    updates it and logs the change at the INFO level.
    
    Required args
    -------------
    - main_loader : torch data.DataLoader
        Torch dataloader.

    Optional args
    -------------
    - val_loader : torch data.DataLoader (default=None)
        Torch dataloader.
    - epoch_n : int (default=0)
        Epoch number.
    - unexp_epoch : int (default=10)
        Epoch as of which unexpected sequences are introduced.
    - test : bool (default=False)
        If True, main_loader is a test dataloader.
    - num_unexp : int (default=4)
        Number of unexpected epochs after onset for which to generate a suffix.

    Returns
    -------
    - suffix : str
        Returns a suffix, specifying which epoch the dataloader is at, since 
        unexpected events were introduced. None, if not applicable.
    """

    if not main_loader.dataset.unexp and epoch_n >= unexp_epoch:
        main_loader.dataset.unexp = True
        loader_mode = "test" if test else "train"
        dataset_str = f"{loader_mode} dataset"
        if val_loader is not None and not val_loader.dataset.unexp:
            val_loader.dataset.unexp = True
            dataset_str = (f"{loader_mode} and val datasets")

        logger.info(f"Setting {dataset_str} to include unexpected sequences.", 
            extra={"spacing": "\n"}
            )

    suffix = None
    n = int(epoch_n - unexp_epoch  + 1)
    if n >=0 and n <= num_unexp:
        suffix = misc_utils.get_order_str(n)

    return suffix


#############################################
def update_gabors(main_loader, val_loader=None, seed=None, epoch_n=0, 
                  unexp_epoch=10, test=False, num_unexp=4):
    """
    update_gabors(main_loader)

    Updates Gabors positions and sizes, as well as the unexpected attribute, 
    if applicable.
    
    Required args
    -------------
    - main_loader : torch data.DataLoader
        Torch dataloader.

    Optional args
    -------------
    - val_loader : torch data.DataLoader (default=None)
        Torch dataloader.
    - seed : int (default=None)
        Seed.
    - epoch_n : int (default=0)
        Epoch number.
    - unexp_epoch : int (default=10)
        Epoch as of which unexpected sequences are introduced.
    - test : bool (default=False)
        If True, main_loader is a test dataloader.
    - num_unexp : int (default=4)
        Number of unexpected epochs after onset for which to generate a suffix.

    Returns
    -------
    - seed : int
        Base seed value used, randomly selected if the input seed value is None.
    - suffix : str
        Returns a suffix, specifying which epoch the dataloader is at, since 
        unexpected events were introduced. None, if not applicable.
    """

    seed = update_dataset_possizes(
        main_loader, val_loader, seed=seed, incr=epoch_n
        )
    
    suffix = update_unexp(
        main_loader, val_loader, epoch_n=epoch_n, 
        unexp_epoch=unexp_epoch, test=test, num_unexp=num_unexp
        )

    return seed, suffix

    
###########################################
def get_gabor_sup_target_to_store(dataset, sup_target):
    """
    get_gabor_sup_target_to_store(dataset, sup_target)

    Returns full supervised target to store for Gabor data, with labels decoded 
    into (image type, mean ori (in degrees)).

    Required args
    -------------
    - dataset : gabor_stimuli.GaborSequenceGenerator
        Gabor dataset
    - sup_target : Tensor
        Supervised target returned by the Gabors dataset for each sequence, 
        with dims: B x N x L  x 2 [label, unexp_label]


    Returns
    -------
    - sup_target : list
        Supervised target, with decoded labels, and dims: 
        B x N x L  x 2 [image type, ori]
    """

    if isinstance(dataset, str):
        raise ValueError("'dataset' should be a Gabor dataset object.")

    seq_labels, seq_unexp = torch.moveaxis(sup_target, -1, 0)
    sup_target = dataset.image_label_to_class(seq_labels, seq_unexp)

    return sup_target
    

#############################################
def get_gabor_sup_label(sup_target, warn=False):
    """
    get_gabor_sup_label(sup_target)

    Returns a single supervised target for each batch item, to allow training 
    supervised models on Gabor data.

    Required args
    -------------
    - sup_target: Tensor
        Supervised target returned by the Gabors dataset for each sequence, 
        with dims: 
            B x N x L x 2, where the last dimension is [label, unexp_label]

    Optional args
    -------------
    - warn : bool (default=False)
        If True, a warning is emitted about how the supervised targets are 
        determined.

    Returns
    -------
    - sup_label : list
        Specific supervised label to train on, with dims: batch size (B) x 1
    """

    if len(sup_target.shape) != 4:
        raise ValueError(
            "'sup_target' should have 4 dimensions "
            "(B x N x L x (label, unexp))."
            )

    B, N, L, _ = sup_target.shape

    pred_idx = -1
    if warn:
        warnings.warn(
            "The supervised task for the Gabors dataset is currently "
            "implemented to predict the label (image type/mean orientation) "
            "of the final frame of the final sequence "
            f"(frame {L} of sequence {N})."
            )

    sup_label = sup_target[:, pred_idx, pred_idx, 0].reshape(B, 1)

    return sup_label


##############################################
def warn_supervised(dataset):
    """
    warn_supervised(dataset)
    
    Warns about how the specific target labels are selected for supervised 
    learning on a Gabor dataset.

    Required args
    -------------
    - dataset : gabor_stimuli.GaborSequenceGenerator
        Gabor dataset
    """

    if isinstance(dataset, str):
        raise ValueError("'dataset' should be a Gabor dataset object.")

    if dataset.mode == "test":
        raise ValueError(
            "Single supervised targets have not been set for Gabors "
            "dataset in 'test' mode. Use 'val' mode instead."
            )
    
    B = 1
    N = dataset.num_seq
    L = dataset.seq_len
    dummy_arr = np.empty([B, N, L, 2])

    get_gabor_sup_label(dummy_arr, warn=True)


#############################################
def get_U_prob_str(U_prob=0.08, unexp=True):
    """
    get_U_prob_str()

    Returns a string specifying the probability of U frames, if applicable.

    Optional args
    -------------
    - U_prob : float (default=0.08)
        Probability of U frames.
    - unexp : bool (default=False)
        Whether unexpected sequences are included.
    
    Returns
    -------
    - U_prob_str : str
        String specifying probability of U frames.
    """
    
    U_prob_str = ""
    if unexp:
        U_perc = U_prob * 100
        U_perc = int(U_perc) if int(U_perc) == U_perc else U_perc
        U_prob_str = f", U freq: {U_perc}%"

    return U_prob_str


#############################################
def plot_gabor_conf_mat(gabor_conf_mat, mode="train", epoch_n=0, 
                        nest_frames=False, output_dir="."):
    """
    plot_gabor_conf_mat(gabor_conf_mat)

    Plots and saves a Gabor confusion matrix from a GaborConfusionMeter object 
    or storage dictionary.

    Required args
    -------------
    - gabor_conf_mat : GaborConfusionMeter or dict
        GaborConfusionMeter object or storage dictionary
    
    Optional args
    -------------
    - mode : str (default="train")
        Dataset mode (i.e., "train", "val", or "test"), for use in plot title 
        and save name.
    - epoch_n : int (default=0)
        Epoch number, for use in plot title and save name,
    - nest_frames : bool (default=False)
        Whether to nest frames (image types) along each confusion matrix axis, 
        instead of preserving the class label order.
    - output_dir : str or path
        Directory in which to save the plotted confusion matrix.
    """

    if isinstance(gabor_conf_mat, dict):
        conf_mat_dict = gabor_conf_mat
        keys = ["class_names", "unexp"]
        dict_types = ["ConfusionMeter", "GaborConfusionMeter"]
        for key, dict_type in zip(keys, dict_types):
            if key not in conf_mat_dict.keys():
                raise RuntimeError(
                    f"Expected to find a {dict_type} storage dictionary."
                    )
        gabor_conf_mat = GaborConfusionMeter(
            conf_mat_dict["class_names"],
            U_prob=conf_mat_dict["U_prob"],
            unexp=conf_mat_dict["unexp"]
            )
        gabor_conf_mat.load_from_storage_dict(conf_mat_dict)

    U_prob_str = get_U_prob_str(gabor_conf_mat.U_prob, gabor_conf_mat.unexp)

    title = f"Epoch {epoch_n} ({mode}{U_prob_str})"

    nest_frame_str = "_nest_fr" if nest_frames else ""
    savename = f"{mode}{nest_frame_str}_{epoch_n:03}.svg"

    gabor_conf_mat_path = Path(output_dir, savename)

    gabor_conf_mat.plot_mat(
        gabor_conf_mat_path, nest_frames=nest_frames, title=title
        )


#############################################
def get_gabor_conf_mat_dict_path(output_dir="."):
    """
    get_gabor_conf_mat_dict_path()

    Returns path for the Gabor confusion matrix dictionary file.

    Optional args
    -------------
    - output_dir : str or path (default=".")
        Main directory in which to save the plotted confusion matrix data, 
        under the GABOR_CONF_MAT_DIREC directory. 

    Returns
    -------
    - gabor_conf_mat_dict_path : path
        Path under which the Gabor confusion matrix dictionary file should be 
        stored.
    """

    output_dir = Path(output_dir, GABOR_CONF_MAT_DIREC)
    gabor_conf_mat_dict_path = Path(output_dir, "gabor_confusion_mat_data.json")

    return gabor_conf_mat_dict_path


#############################################
def plot_save_gabor_conf_mat(gabor_conf_mat, mode="train", epoch_n=0, 
                             nest_frames=False, output_dir=".", 
                             raise_exists=False, skip_plot=False):
    """
    plot_save_gabor_conf_mat(gabor_conf_mat)

    Plots and saves a Gabor confusion matrix from a GaborConfusionMeter 
    object, and saves its storage dictionary under an epoch key "epoch_{n}"
    to a json by adding it to an existing file, if it exists, or creating a 
    new one.

    Required args
    -------------
    - gabor_conf_mat : GaborConfusionMeter
        GaborConfusionMeter object
    
    Optional args
    -------------
    - mode : str (default="train")
        Dataset mode (i.e., "train", "val", or "test"), for use in plot title 
        and save name.
    - epoch_n : int (default=0)
        Epoch number, for use in plot title and save name,
    - nest_frames : bool (default=False)
        Whether to nest frames (image types) along each confusion matrix axis, 
        instead of preserving the class label order.
    - output_dir : str or path (default=".")
        Main directory in which to save the plotted confusion matrix under the 
        GABOR_CONF_MAT_DIREC directory. Also, the directory from which to load 
        the json file, if it exists, and where the updated or new json file is 
        saved.
    - raise_exists : bool (default=False)
        If True and the epoch number key exists, an error is raised. Otherwise, 
        a warning is thrown and the key is overwritten.
    - skip_plot : bool (default=False)
        If True, plotting is skipped (e.g., to save time).
    """

    gabor_conf_mat_dict_path = get_gabor_conf_mat_dict_path(output_dir)

    output_dir = gabor_conf_mat_dict_path.parent
    
    if not skip_plot:
        plot_gabor_conf_mat(
            gabor_conf_mat, mode=mode, epoch_n=epoch_n, 
            nest_frames=nest_frames, output_dir=output_dir
            )

    gabor_conf_mat_dict = dict()
    if gabor_conf_mat_dict_path.is_file():
        with open(gabor_conf_mat_dict_path, "r") as f:
            gabor_conf_mat_dict = json.load(f)

    if mode not in gabor_conf_mat_dict.keys():
        gabor_conf_mat_dict[mode] = dict()

    # only overwrite for test mode
    epoch_key = f"epoch_{epoch_n}"
    if mode != "test" and epoch_key in gabor_conf_mat_dict[mode]:
        msg = f"Epoch key for epoch {epoch_n}, {mode} mode already exists."
        if raise_exists:
            raise RuntimeError(msg)
        else:
            warnings.warn(f"{msg} It will be overwritten.")
            time.sleep(5) # to allow for skipping file removal.

    
    gabor_conf_mat_dict[mode][epoch_key] = \
        gabor_conf_mat.get_storage_dict()

    gabor_conf_mat_dict_path.parent.mkdir(exist_ok=True, parents=True)
    with open(gabor_conf_mat_dict_path, "w") as f:
        json.dump(gabor_conf_mat_dict, f)


#############################################
def load_plot_gabor_conf_mat(gabor_conf_mat_dict_path, nest_frames=False, 
                             output_dir=None, parallel=False):
    """
    load_plot_gabor_conf_mat(gabor_conf_mat_dict_path)

    Loads and plots Gabor Gabor confusion matrices from a json, in which they 
    are stored by epoch.

    Required args
    -------------
    - gabor_conf_mat_dict_path : str or Path
        location at which the json dictionary containing GaborConfusionMeter 
        storage dictionaries for each epoch is stored.
    
    Optional args
    -------------
    - mode : str (default="train")
        Dataset mode (i.e., "train", "val", or "test"), for use in plot title 
        and save name.
    - nest_frames : bool (default=False)
        Whether to nest frames (image types) along each confusion matrix axis, 
        instead of preserving the class label order.
    - output_dir : str or path (default=".")
        Main directory in which to save the plotted confusion matrices under 
        the GABOR_CONF_MAT_DIREC directory. If None, it is set to be the parent 
        directory of gabor_conf_mat_dict_path.
    - parallel : bool (default=False)
        If True, confusion matrices for different epochs are loaded and 
        replotted in parallel.
    """

    gabor_conf_mat_dict_path = Path(gabor_conf_mat_dict_path)
    if not gabor_conf_mat_dict_path.is_file():
        raise OSError(f"{gabor_conf_mat_dict_path} is not a file.")
    
    with open(gabor_conf_mat_dict_path, "r") as f:
        gabor_conf_mat_dict = json.load(f)

    plot_kwargs = {
        "nest_frames": nest_frames 
    }

    if output_dir is None:
        plot_kwargs["output_dir"] = gabor_conf_mat_dict_path.parent
    else:
        plot_kwargs["output_dir"] = Path(output_dir, GABOR_CONF_MAT_DIREC)

    if not isinstance(gabor_conf_mat_dict, dict):
        raise RuntimeError(
            f"Expected {gabor_conf_mat_dict_path} to be storing a dictionary."
            )

    for mode_key, mode_dict in gabor_conf_mat_dict.items():
        if not isinstance(mode_dict, dict):
            raise RuntimeError(
                f"Expected {gabor_conf_mat_dict_path} to be storing "
                "nested dictionaries."
                )        
        
        plot_kwargs["mode"] = mode_key

        # collect epoch numbers and unexp values
        epoch_ns = []
        epoch_prefix = "epoch_"
        for epoch_key, conf_mat_dict in mode_dict.items():
            if not epoch_key.startswith(epoch_prefix):
                raise KeyError(
                    "Expected to find only keys of the form 'epoch_x', but "
                    f"found {epoch_key}"
                    )
            epoch_n = int(epoch_key.replace(epoch_prefix, ""))
            epoch_ns.append(epoch_n)

        num_epochs = len(mode_dict)
        logger.info(
            f"Loading and plotting Gabor confusion matrices for {num_epochs} "
            f"epochs ({mode_key} mode).", extra={"spacing": "\n"}
            )

        if parallel:
            n_jobs = misc_utils.get_num_jobs(len(conf_mat_dict.keys()))

            Parallel(n_jobs=n_jobs)(
                delayed(plot_gabor_conf_mat)(
                    mode_dict[f"{epoch_prefix}{epoch_n}"], 
                    epoch_n=epoch_n, **plot_kwargs
                    ) for epoch_n in tqdm(epoch_ns, total=num_epochs)
            )
        
        else:
            for epoch_n in tqdm(epoch_ns, total=num_epochs):
                plot_gabor_conf_mat(
                    mode_dict[f"{epoch_prefix}{epoch_n}"], 
                    epoch_n=epoch_n, **plot_kwargs
                    )


#############################################
def init_gabor_conf_mat(dataset):
    """
    init_gabor_conf_mat(dataset)

    Initializes a GaborConfusionMeter object based on a Gabor dataset.

    Required args
    -------------
    - dataset : gabor_stimuli.GaborSequenceGenerator
        Gabor dataset

    Returns
    -------
    - confusion_mat : GaborConfusionMeter
        GaborConfusionMeter object
    """

    if isinstance(dataset, str):
        raise ValueError("'dataset' should be a Gabor dataset object.")

    gabor_classes = list(dataset.class_dict_encode.keys())
    confusion_mat = GaborConfusionMeter(
        gabor_classes,
        U_prob=dataset.U_prob,
        unexp=dataset.unexp
        )

    return confusion_mat


#############################################
def init_gabor_records(dataset):
    """
    init_gabor_records(dataset)

    Initializes a GaborConfusionMeter object based on a Gabor dataset.

    Required args
    -------------
    - dataset : gabor_stimuli.GaborSequenceGenerator
        Gabor dataset
    
    Optional args
    -------------
    - init_conf_mat : bool (default=True)
        If True, a GaborConfusionMeter is initialized for the dataset. 
        Otherwise, None is returned.

    Returns
    -------
    - loss_dict : dict
        Dictionary for collecting loss data, with keys
        '{image_type}' (list)       : image type loss, for each batch
        '{mean ori}' (list)         : orientation loss, for each batch
        'image_types_overall' (list): overall image type loss, for each 
                                        batch
        'mean_oris_overall'   (list): overall mean ori loss, for each batch
        'overall'             (list): overall loss, for each batch
    - acc_dict : dict
        Dictionary for collecting accuracy data, with the same keys as 
        loss_dict.
    """

    if isinstance(dataset, str):
        raise ValueError("'dataset' should be a Gabor dataset object.")

    gabor_classes = list(dataset.class_dict_encode.keys())

    # initialize loss/accuracy dictionaries
    loss_dict = dict()
    acc_dict = dict()

    for gabor_image, gabor_ori in gabor_classes:
        gabor_image = str(gabor_image)
        gabor_ori = str(gabor_ori)
        if gabor_ori != "N/A":
            gabor_ori = str(float(gabor_ori)) # for consistency
        if gabor_image not in loss_dict.keys():
            loss_dict[gabor_image] = list()
            acc_dict[gabor_image] = list()
        if gabor_ori not in loss_dict.keys():
            loss_dict[gabor_ori] = list()
            acc_dict[gabor_ori] = list()
    
    for key in ["image_types_overall", "mean_oris_overall", "overall"]:
        acc_dict[key] = list()
        loss_dict[key] = list()

    return loss_dict, acc_dict


#############################################
def update_records(dataset, loss_dict, acc_dict, output, sup_target, 
                   batch_loss, supervised=False, confusion_mat=None):
    """
    update_records(dataset, loss_dict, acc_dict, output, sup_target, 
                   batch_loss)

    Updates loss and accuracy dictionaries, and optionally a 
    GaborConfusionMeter, with loss and accuracy data broken up by gabor image 
    type and mean orientation.

    Required args
    -------------
    - dataset : gabor_stimuli.GaborSequenceGenerator
        Gabor dataset
    - loss_dict : dict
        Dictionary to update (in place) with loss data, with keys
        '{image_type}' (list)       : image type loss, for each batch
        '{mean ori}' (list)         : orientation loss, for each batch
        'image_types_overall' (list): overall image type loss, for each 
                                        batch
        'mean_oris_overall'   (list): overall mean ori loss, for each batch
        'overall'             (list): overall loss, for each batch
    - acc_dict : dict
        Dictionary to update (in place) with accuracy data, with the same keys 
        as loss_dict.
    - output : 2D Tensor
        Model output. If supervised, the dimensions are B x number of classes. 
        Otherwise, the dimensions are B * P * D_out2 x B_per * P * D_out2
    - sup_target : 4D Tensor
        Supervised target returned by the Gabors dataset for each sequence, 
        with dims: 
            B x N x L x 2, where the last dimension is [label, unexp_label]
    - batch_loss : 2D Tensor
        Loss for each image. If supervised, the dimensions are B. 
        Otherwise, the batch loss is averaged across the spatial dimension, 
        and the dimensions are B x P (prediction step).

    Optional args
    -------------
    - supervised : bool (default=False)
        If True, loss and accuracy are calculated based on a supervised task, 
        instead of the Dense CPC task.
    - confusion_mat : GaborConfusionMeter or None (default=None)
        GaborConfusionMeter to update (in place).
    """

    if supervised:
        target_labels = get_gabor_sup_label(sup_target).reshape(-1)
        pred_labels = output.argmax(axis=1).reshape(-1)

    else:
        B, P = batch_loss.shape
        D_out2 = output.shape[0] / np.product(B * P)
        if int(D_out2) != D_out2:
            raise RuntimeError(
                "Failed to calculate the flattened spatial dimension "
                "(D_out2) from 'output' and 'batch_loss' shapes."
                )
        D_out2 = int(D_out2)

        main_shape = (B, P, D_out2)

        # retrieve a prediction for each batch example / prediction step
        pred = loss_utils.get_predictions(
            output, keep_topk=1, spatial_avg=True, main_shape=main_shape
            )[0].reshape(-1)

        # retrieve target for first frame of each predicted sequences
        target_labels, _ = sup_target[:, -P:, 0].reshape(B * P, -1).T
        pred_labels = target_labels[pred]

    # update confusion matrix
    if confusion_mat is not None:
        confusion_mat.update(pred_labels, target_labels)

    # find proportion of correct supervised predictions
    label_decode_dict = dataset.class_dict_decode

    target_classes = image_label_to_class(label_decode_dict, target_labels)
    pred_classes = image_label_to_class(label_decode_dict, pred_labels)

    target_im_types, target_mean_oris = [
        np.asarray(val) for val in zip(*target_classes)
        ]
    target_mean_oris = target_mean_oris.astype(str)

    pred_im_types, pred_mean_oris = [
        np.asarray(val) for val in zip(*pred_classes)
        ]
    pred_mean_oris = pred_mean_oris.astype(str)
    
    correct_image_types = (target_im_types == pred_im_types)
    correct_mean_oris = (target_mean_oris == pred_mean_oris)
    correct_both = np.asarray(target_labels == pred_labels)
    if (correct_both != (correct_image_types * correct_mean_oris)).any():
        raise RuntimeError(
            "'correct_both' should match value inferred from "
            "'correct_image_types' and 'correct_mean_oris', but does not, "
            "suggesting a label interpretation error."
            )

    # add to lists
    batch_loss = batch_loss.reshape(-1)
    for key in loss_dict.keys():
        str_key = str(key)
        if str_key == "N/A" or "." in str_key or str_key.isdigit(): # oris
            idx = (target_mean_oris == str_key)
            n_correct = correct_mean_oris[idx].sum()
        else: # frames
            idx = (target_im_types == key)
            n_correct = correct_image_types[idx].sum()

        n_vals = sum(idx).item()
        if n_vals == 0:
            loss_dict[key].append(np.nan)
            acc_dict[key].append(np.nan)
        else:
            loss_dict[key].append(batch_loss[idx].mean().item())
            acc_dict[key].append(n_correct.item() / n_vals)

    keys = ["image_types_overall", "mean_oris_overall", "overall"]
    all_data = [correct_image_types, correct_mean_oris, correct_both]
    for key, data in zip(keys, all_data):
        n_total = len(data)
        acc_dict[key].append(data.sum().item() / n_total)
        loss_dict[key].append(batch_loss.mean().item()) # can't distinguish


#############################################
if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--gabor_conf_mat_dict_path", default=None,
        help="path of Gabor confusion matrix data to replot")
    parser.add_argument("--nest_frames", action="store_true",
        help="If True, Gabor frames are nested instead of orientations")

    parser.add_argument("--output_dir", default=None, 
        help=("directory in which to save files. If None, it is inferred from "
        "the Gabor confusion matrix dictionary path)"))
    parser.add_argument('--log_level', default='info', 
        help='logging level, e.g., debug, info, error')
    parser.add_argument("--parallel", action="store_true", 
        help="replot Gabor confusion matrices in parallel")

    args = parser.parse_args()

    misc_utils.get_logger_with_basic_format(level=args.log_level)


    if args.gabor_conf_mat_dict_path is None:
        breakpoint()
    else:
        load_plot_gabor_conf_mat(
            args.gabor_conf_mat_dict_path, 
            nest_frames=args.nest_frames, 
            output_dir=args.output_dir,
            parallel=args.parallel,
            )
